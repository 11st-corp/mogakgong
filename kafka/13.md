# 13. 카프카의 발전과 미래

## 13.1 주키퍼 없는 카프카의 미래

### 13.1.1 주키퍼 사용에 따른 제약사항

중앙 데이터 파이프라인 역할을 하는 카프카가 점점 더 많은 메시지를 처리하고 카프카를 여러 파이프라인에서 사용하게 되면서 주키퍼에 대한 문제가 발생하기 시작했다.

**컨슈머의 오프셋 저장소 전환**

카프카 2.0 이전 버전에서는 컨슈머 그룹의 저장소로 주키퍼의 지노드를 이용했다.

이는 메시지 수가 늘어나면서 오프셋 숫자가 커지고 컨슈머의 숫자도 늘어남에 따라 주키퍼에 대한 부담이 커졌고, 16년도 카프카 0.10버전부터 컨슈머의 오프셋 저장소를 카프카의 내부 토픽인 `__consumer__offsets`로 이전하였다.

**각기 다른 애플리케이션 운영에 대한 부담**

주키퍼와 카프카는 완전한 별개의 프로젝트이고 각자가 추가하는 방향성 또한 다른 애플리케이션이다.

이렇게 다른 애플리케이션을 함께 운영하다보니 여러가지 부하가 발생하였다.

- 각기 다른 api 사용에 따른 부담
  - 두 가지 개별 애플리케이션 운영으로 인해 api 간의 호환성, 사용 방법이 달라 혼동과 함께 생산성 저하 발생
- 운영의 어려움
  - 카프카의 경우 주키퍼라는 애플리케이션을 추가로 사용하므로 습득해야하는 지식이 2배가 됨
  - 안정적인 모니터링을 위해 시스템을 구성하는 경우 카프카뿐 아니라 주키퍼에 대해서도 대응되어야하므로 결국 2배의 운영 리소스가 필요
- 보안 문제
  - 서로 다른 애플리케이션에 대한 각각의 보안 적용이 필요함
  - 각기 다른 보안을 구성한 후 상호간의 통신이나 권한 문제를 확인해야하므로 역시나 운영 리소스가 큼
- 메타 데이터 관리
  - 주키퍼에는 카프카가 사용하는 모든 메타데이터가 저장됨
  - 카프카 사용량이 높아 메타 데이터가 매우 커진 경우에 기존 컨트롤러에 장애가 발생한다면 새로운 컨트롤러가 선정되고 액티브되기까지 매우 긴 다운타임이 발생할 수 있음
  - 변경사항이 발생하는 경우 길게는 수 초간 컨트롤러와 주키퍼 간의 메타데이터가 불일치하는 상황이 발생할 수 있음
  - 일반 사용자 또한 주키퍼에 접근 가능하므로 저장된 메타데이터를 조작하거나 삭제가 가능함

<br>

### 13.1.2 주키퍼 의존성을 제거한 카프카 업그레이드

카프카에서 주키퍼 의존성을 제거하기 위해 주키퍼에 저장해둔 메타데이터를 카프카로 이동시킬 수 있다.

기존에는 주키퍼와의 통신을 담당하는 특정 브로커가 하나의 컨트롤러가 되고 메타데이터 업데이트 등의 역할을 수행하고 다른 브로커들에게 메타 데이터를 푸시하는 방식으로 동작했다.

주키퍼에 의존성을 제거한 카프카에서는 주키퍼의 역할을 대체하는 3대의 컨트롤러가 존재하고 컨트롤러 노드들 중 하나는 컨트롤러 리더가 된다.

이 때, 기존과 같이 컨트롤러가 푸시하는 방식이 아닌 다른 브로커들이 컨트롤러부터 메타데이터를 당겨오는 풀 방식으로 변경된다.

<br>

## 13.2 새로운 합의 프로토골: KRaft

컨트롤러 노드는 총 3대로 구성되며 분산된 노드간의 합의가 필요하다.

기존에는 주키퍼의 합의 프로토콜을 사용해 리플리케이션 커밋, 리더 선출 등의 동작을 처리했지만 주키퍼에 대한 의존성을 제거한 버전에서는 새로운 합의 프로토콜이 필요하다.

이를 위해 KRaft 합의 프로토콜이 개발되었다.

기본적은 Raft 합의 프로토컬은 내부적인 합의를 통해 정보를 유지하는데, 여러 서버들의 동의가 필요하다.

일반적으로 과반수 찬성 방식을 따르기 때문에 3대의 클러스터에서 1대가 고장나더라도 클러스터는 중지하지 않고 안정적인 서비스를 할 수 있다.

Raft의 리더 선출 과정에서 노드들은 팔로워, 후보자, 리더라는 총 3가지 상태를 갖게되고 모든 노드들의 최초 상태는 팔로워이다.

노드들은 리더로부터 하트비트를 받아 health check를 하고, 타임아웃 시간동안 하트비트를 받지 못한다면 팔로워 상태의 노드는 후보자 상태가 되어 다른 노드들에게 투표를 요창하게 된다.

이 떄, 과반수 이상의 투표를 받으면 새로운 리더 노드로 변경된다.

동작 방식에는 큰 차이가 없지만 KRaft에서는 푸시기반이 아닌 풀 기반을 사용하며 오프셋, 에포크와 같은 용어를 사용한다.

KRaft 모드를 사용하면 메타데이터를 카프카에서 직접 관리하며 리더 컨트롤러는 무한정 커지지 않도록 주기적으로 스냅샷을 생성한다.

다른 컨트롤러들에서 장애가 발생하면 전체 데이터를 복구하는 것이 아니라 스냅샷에서 필요한 부분만 복구하므로 획기적으로 복구 시간을 단축할 수 있게 된다.

<br>

## 13.3 최적화된 컨트롤러 노드 구성

- 클러스터 내 임의의 브로커 3대를 컨트롤러로 선정하고 동일한 노드에서 브로커, 컨트롤러 프로세스를 실행하는 방법
  - 컨트롤러 노드를 위한 별도의 노드나 서버가 필요하지 않으므로 서버를 절약할 수 있음
- 클러스터 내 실행되는 브로커 노드와 컨트롤러 노드를 분리해 별도의 서버에 구성하는 방법
  - 노드의 장애가 발생할 경우 문제가 되는 노드에서 실행되고 있는 단일 프로세스만 종료되어 안정성을 높일 수 있음
