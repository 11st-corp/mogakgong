# 13. 카프카의 발전과 미래

# 주키퍼 없는 카프카의 미래

주키퍼 의존성 이슈

- 컨슈머 오프셋 저장소 전환
  - 주키퍼를 오프셋 저장소로 사용했더니 메시지 수가 늘어나면서 주키퍼에 대한 부담이 커짐 → 카프카 0.10부터 컨슈커의 오프셋 저장소를 내부 토픽인 __consumer_offsets로 이전하여 컨슈머의 주키퍼 의존성 완전 제거
- 각기 다른 애플리케이션 운영에 대한 부담
  - 안전한 분산 코디네이터 시스템의 용도로만 주키퍼를 사용하다보니, 두 애플리케이션을 운영해야하는 부하 발생
  - ex. 각기 다른 API사용, 운영 업무 부담, 보안 문제, 메타데이터 관리의 어려움

## 주키퍼 의존성을 제거한  카프카 업그레이드

주키퍼 의존성을 제거하는 방법

- 주키퍼에 저장해둔 메타데이터를 카프카로 이동
- as is : 주키퍼를 사용하는 카프카 구성도
  - 하나의 컨트롤러가 주키퍼와의 통신을 담당
<img width="603" alt="image" src="https://github.com/user-attachments/assets/9ae1ca32-0d0b-4016-b842-e79e4db4e460">

- to be : 주키퍼를 제거한 카프카 구성도
  - 주키퍼를 대체하는 컨트롤러 여러대 생성
  - 리더 역할의 컨트롤러 노드 하나에서 여러 대의 컨트롤러가 당겨오는 pull 방식    
<img width="638" alt="image" src="https://github.com/user-attachments/assets/e6905ae9-58c1-4ddf-ac2a-9e4f2571bccd">


- 한 번에 의존성 제거된 카프카 클러스터로 업그레이드하지말고, 주간에 주키퍼 의존성을 완전히 격리시키는 브리지(bridge-임의) 릴리스 버전으로 업그레이드 진행
  - 8.2 주키퍼 의존성이 있는 카프카 롤링 업그레이드 참고

# KRaft - 새로운 합의 프로토콜

- 새롭게 추가된 컨트롤러 구성 → 분산 노드 간에 의사결정을 위한 합의 필요
  - as is : 주키퍼의 합의 프로토콜 이용
  - to be : 카프카용 Raft (KRaft) 합의 프로토콜 이용
- 카프카용 Raft가 있는 이유
  - 카프카와 Raft간에 처리 방식과 용어 간에 괴리가있어서
- 리더 컨트롤러 선출 과정
  - 리더 컨트롤러 선출 과정에서 컨트롤러 노드들은 ‘팔로워’, ‘후보자’, ‘리더’ 라는 세 가지 상태를 가짐
    - 처음에는 모두 팔로워에서 시작
    - 리더로부터 하트비트를 받아 상태 체크 - 타임아웃 시간동안 못받으면 후보자 상태로 전환 & 다른 노드들 투표
    - 후보자 상태의 노드가 과반 투표를 받으면 새로운 리더로 변경
  - 리더에 문제가 발생하여 하트비트를 받지 못하면, 팔로워들은 투표 반복해서 새로운 리더 선출
- 장애 발생시 전체가 아닌 스냅샷에 필요한 부분만 복구
  - 복구 시간 단축으로, 성능 향상 기대

# 최적화된 컨트롤러 노드 구성

<img width="666" alt="image" src="https://github.com/user-attachments/assets/69da7b9c-17ae-4b34-a54b-9a0d8ecbfe26">

1 번 방식

- 컨트롤러 노드를 위한 별도 노드/서버 가 필요하지 않아 서버 비용 절약

2번 방식

- 노드에서 장애가 발생하면 문제가 되는 노드의 프로세스만 종료 → 안정성이 높음
- 각 노드에 할당된 리소스 단독 사용 가능

→ 환경과 운영 방식에 따라 효율적인 방법 채택하자!

# 카프카의 미래가 담긴 KIP

KIP(Kafka Improvement Proposals)사이트

- [https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Improvement+Proposals](https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Improvement+Proposals)
- 카프카의 성장사 또는 미래의 모습 관찰 가능
- 카프카 개선사항을 제안하는 곳으로서, 이를 기반으로 다양한 기능들이 개선됨
