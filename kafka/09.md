# 9. 카프카 보안
기본적으로 최초 설치 과정에서 보안이 설정되지 않음

→ 어떤 클라이언트이든지 카프카와 동일한 네트워크에 위치하거나 통신이 가능하면 자유롭게 카프카와 연결 가능
→ 보안 취약

# 카프카 보안의 세 가지 요소

취약점 보완을 위한 세 가지 보안 요소

- 암호화 - 데이터 암호화
    - SSL(Secure Socket Layer) 
    : 인증기관(CA)로부터 인증서를 받아, 공개키 + 프라이빗키 방식으로 서버와 클라이언트가 암호화/복호화 하면서 통신. 키 방식은 다시 대칭키/비대칭키로 나뉨
- 인증 - 안전하다고 확인된 클라이언트만 접근
    - SASL(Simple Authentication and Security Layer)
    : SCRAM, GSSAPI, OPLAIN, AUTHBEARER,DIGEST-MD5 등이 있음.
    카프카는 네 가지 메커니즘(GSSAPI, PLAIN, SCRAM-SHA-256, SCRAM-SHA-512, OAUTHBEARER)을 지원
    커버로스를 이용한 GSSAPI를 가장 많이 사용함
- 권한 - 인증 받은 클라이언트의 권한 설정 (제한)
    - ACL(Access Control List)
    : 카프카 클라이언트마다 올바른 권한을 할당하는 것

# SSL을 이용한 카프카 암호화

일반적인 자바 애플리케이션 

- KeyStore라고 불리는 인터페이스를 통해 공개키, 프라이빗키, 인증서를 추상화하여 제공
- Keytool 명령어로 카프카에 SSL 적용 작업을 진행

## 클러스터에서의 적용

<img width="1247" alt="image" src="https://github.com/user-attachments/assets/95ff59ea-d495-45e2-9d32-8c7913891e36">

1. 브로커 키스토어 생성
    - 트러스트스토어(TrustStore) 키스토어(KeyStore) 모두 keytool로 관리
    - 키스토어 :
        - 서버쪽
        - 프라이빗 키 저장
        - 인증서 저장
        - 자격 증명 제공
        - 민감한 정보 저장
    - 트러스트스토어 :
        - 클라이언트 쪽
        - 서버가 제공하는 인증서를 검증하기 위한 퍼블릭키 저장
        - 서버와 SSL 연결에서 유효성을 검사하는 서명된 인증서를 저장
        - 민감한 정보 저장X
2. CA 인증서 생성
    - ‘이 웹사이트의 보안 인증서에 문제가 있습니다.’  ← CA로부터 서명받지 않은 인증서, 신뢰할 수 없음.
    - 테스트나 로컬 테스트시에는 비용 이슈로, 자체 서명된 CA 인증서 사용
    - 프라이빗키와 인증서 파일이 생성되는데, 프라이빗키는 절대로 유출되어서는 안됨.
3. 트러스트스토어 생성
    - 자체 서명 CA 인증서는 CA를 통해 발급 받지 않았기에, 클라이언트는 인증서를 신뢰할 수가 없음.
    - 클라이언트가 자체 서명 CA 인증서를 신뢰할 수 있도록 트러스트스토어에 추가
4. 인증서 서명 및 복사
    - 키스토어에 저장된 모든 인증서가 자체 서명된 CA의 서명을 받아야 함
    - 키스토어에서 인증서 추출 > 자체 서명된 CA 서명 적용 > 키스토어에 자체서명된 CA 인증서 추가.
5. 나머지 브로커에서 SSL 구성 → 1, 4 과정(키스토어 생성 및 인증서 추가) 진행
    - 인증서는 처음에 생성한 인증서 복사하여 사용
    - 중간에 트러스트스토어가 브로를 신뢰할 수 있도록, 트러스트스토어로도 복사 진행
6. 브로커 설정에 SSL 추가
    - 모든 브로커에서 브로커 설정 파일(server.properties)의 설정을 변경
    - PLAINTEXT로 통신하는 부분 뒤에 SSL 통신 추가
    - 암호화/복호화 다 적용하면 통신에 대한 오버헤드가 큼 → 브로커 간 통신은 PLAINTEXT로 설정, 브로커-클라이언트 통신은 SSL 적용하여 성능개선 가능
    - 클라이언트용 트러스트스토어 생성

# 커버로스(SASL)을 이용한 카프카 인증

커버로스

- 티켓을 기반으로 한 컴퓨터 네트워크 인증 프로토콜
- 사용자의 신원을 식별하기 위해 사용
- 하나의 커버로스 티켓을 이용하여 여러 서비스에 적용하는 SSO(Single Sign-on)을 지원하기 때문

<img width="2184" alt="image" src="https://github.com/user-attachments/assets/8138653d-11ee-46f0-bd45-f0ab9e231a82">

- 커버로스 구성
    - 커버로스 서버 설치 후, 프린시펄 개체 생성하여 해당 프린시펄의 키탭 생성
        - 프린시펄과 키탭 사용시 비밀번호 없이 입력 가능
- 브로커 커버로스 설정
    - 모든 브로커에 커버로스 설정 적용하기
        - [server.properties](http://server.properties) 파일을 열어 listners, advertised.listeners, security.inter.broker.protocol 항목을 변경
    - 커버로스 인증을 위한 jaas.conf 파일 생성 및 키탬/프린시펄 등을 지정
- 클라이언트 커버로스 설정
    - jaas 설정 파일 추가 (ex. kafka_client_jaas.conf)
    - 콘솔 프로듀서와 콘솔 컨슈머에서 사용할 kerberos.config 파일 성 및 커버로스 설정 추가
        - 티켓 만료시 kinit 명령어로 다시 한번 티켓 발급
        - klist로 정상티켓 발급 확인 가능

# ACL을 이용한 카프카 권한 설정

- 브로커 설정 파일 수정
- 유저별 권한 설정 (kafka-acls.sh)
- 관리자가 원하는 수준까지 보안을 강화하여 카프카 클러스터 운영
- 대부분 기업에서는 보안을 설정하지 않는 것처럼, 공유 관점에서 보면 카프카와 보안은 다소 상충적임 → 보안이 적용된 카프카가 필요하다면, 보안 카프카/비보안 카프카를 분리하여 운영 고려
