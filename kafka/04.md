# 카프카의 내부 동작 원리와 구현

<br>

---

<br>

## 4.1 카프카 리플리케이션

카프카는 고가용성 분산 스트리밍 플랫폼으로서 데이터를 안전하게 저장하고 전달하기 위해 리플리케이션을 사용한다. 

리플리케이션은 카프카의 핵심 개념 중 하나로, 토픽의 파티션을 여러 개의 브로커에 복제하는 것을 의미한다. 

이를 통해 카프카는 데이터의 안정성을 보장하고, 브로커의 장애에 대비할 수 있다.

<br>

### 4.1.1 리플리케이션의 동작 개요

리플리케이션을 위해 카프카 토픽 생성 시 필수값으로 `replication.factor`를 설정해야 한다.

`replication.factor`는 토픽의 파티션을 복제할 브로커의 수를 의미한다.

예를 들어, `replication.factor`가 3이라면, 토픽의 파티션은 3개의 브로커에 복제된다.

총 3개의 복제본이 있으므로 2대의 브로커에 장애가 발생하더라도 남은 1대의 브로커가 데이터를 안전하게 보관할 수 있다.

<br>

### 4.1.2 리더와 팔로워

모두 동일한 리플리케이션이라도 리더만의 역할이 따로 있는데, 이를 이해하기 위해 리더와 팔로워의 개념을 알아야 한다.

리더는 특정 파티션의 데이터를 쓰고 읽는 역할을 담당한다. 이는 데이터의 일관성을 유지하기 위해 필요한 역할이다.

팔로워는 리더로부터 데이터를 복제하는 역할을 담당한다. 이는 데이터의 안정성을 보장하기 위해 필요한 역할이다.

즉, 프로듀셔는 모든 리플리케이션으로 메시지를 보내는 것이 아니라 리더에게 메시지를 전송하고 컨슈머 또한 리더로부터만 메시지를 가져온다.

팔로워는 장애 상황을 대비해 언제라도 새로운 리더가 도리 수 있도록 데이터를 복제한다.

지속적으로 리더의 새로운 메시지를 확인하고 해당 메시지를 리더로부터 복제한다.

<br>

### 4.1.3 복제 유지와 커밋

리더와 팔로워는 ISR(In-Sync Replicas)라는 개념을 통해 데이터의 일관성을 유지한다.

ISR은 리더와 동기화된 팔로워의 집합을 의미한다. ISR에 속한 팔로워는 리더와 동일한 데이터를 가지고 있으므로 언제든지 리더로부터 데이터를 복제할 수 있다.

따라서, 같은 그룹안에 속해있는 팔로워만 리더의 자격을 가질 수 있다.


여러가지 이유로 팔로워가 리더의 메시지를 복제하지 못하는 경우가 발생할 수 있기 때문에 리더는 팔로워의 메시지 복제를 지속적으로 감시하고 ISR에 속하지 않는 팔로워는 제외시킨다.

만약, 팔로워가 특정 주기만큼 복제 요청을 하지 않는다면 리더는 해당 팔로워에 문제가 생겼다고 판단해 ISR 그룹에서 제외시킨다.

리더는 ISR에 속한 팔로워에게 데이터를 복제하고, 모든 팔로워가 데이터를 복제하면 리더는 커밋을 수행한다.

이때 마지막 커밋 오프셋 위치를 하이워터마크라고 부른다.

여기서 커밋은 모든 팔로워가 리더의 새로운 메시지를 복제했다는 것과 동일한 의미이다.

또한, 이렇게 커밋된 메시지만 컨슈머가 읽을 수 있다. 이를 통해 메시지의 일관성을 유지한다.

<br>

### 4.1.4 리더와 팔로워의 단계별 리플리케이션 동작

카프카는 리더와 팔로워 간의 리플리케이션 동작을 처리할 때 상호간의 통신을 최소화하도록 설계하여 리더의 부하를 줄였다.

전통적의 MQ 방식에서는 팔로워의 리플리케이션 요청 이후 ACK 응답을 통해 리더가 팔로워가 리플리케이션에 성공했는지를 확인했지만, 카프카는 ACK를 주고받는 통신이 없다.

대신, 오프셋이 최신화되어 있는 상태인지를 통해 현재 팔로워가 리더로의 리플리케이션 동작을 정상적으로 수행하고 있는지를 판단한다.

예를 들어, 리더의 오프셋0에 메시지1이 있고, 팔로워는 오프셋0에 대한 리플리케이션 요청을 리더에게 했다고 가정하자.

다음 리더의 오프셋1에 메세지2가 있고, 팔로워는 오프셋1에 대한 리플리케이션 요청을 리더에게 하게 될텐데, 이때 오프셋0이 아닌 최신 메시지인 오프셋1에 대한 요청이 왔으므로 리더는 팔로워들의 오프셋0번에 대한 리플리케이션이 성공했다고 판단하고 하이워터마크를 증가시킨다.(커밋)

만약, 성공하지 못했다면 팔로워는 오프셋1이 아닌 오프셋0에 대한 리플리케이션 요청을 했을 것이다.

이러한 방식으로 리더는 팔로워의 리플리케이션 동작을 감시하고, 팔로워는 최신화된 오프셋을 통해 리더의 리플리케이션 동작을 수행한다.

<br>

### 4.1.5 리더에포크와 복구

리더에포크는 카프카의 파티션들이 복구 동작을 할 때 메시지의 일관성을 유지하는 용도로 사용된다.

컨트롤러에 의해 관리되는 32비트의 숫자로 표현되고 해당 정보는 리플리케이션 프로토콜에 의해 전파되어 새로운 리더가 선출될 경우 변경된 리더에 대한 정보가 팔로워에게 전달된다.

또, 복구 동작 시 하이워터마크를 대체하는 수단으로도 활용된다.

리더에포크는 리더가 커밋한 마지막 오프셋을 의미하므로, 복구 동작 시 리더에포크를 기준으로 복구를 수행한다.

즉, 리더에포크를 사용하지 않는다면 복구 동작시 하이워터마크를 기준으로 복구를 수행하므로, 하이워터마크 이후의 메시지는 복구되지 않는다.

이 상태에서 리더에도 갑작스러운 장애가 발생한다면 리더에만 존재하던 최신 메시지는 유실되고 말 것이다.

따라서, 리더에포크는 리더의 커밋 오프셋을 기준으로 복구를 수행하여 메시지의 일관성을 유지한다.

<br>

---

<br>

## 4.2 컨트롤러

카프카 클러스터 중 하나의 브로커가 컨트롤러로 선출되어 클러스터의 메타데이터를 관리한다.

여기에는 파티션의 ISR 중 리더를 선출하는 역할도 포함되어 있다.

컨트롤러는 브로커가 실패하는 것을 감시하고 있으며, 만약 실패를 감지한경우 즉시 ISR 중 다른 브로커를 새로운 리더로 선출한다.

그 후, 새로운 리더의 정보를 주키퍼에 기록하고 변경된 정보를 모든 브로커에게 전달한다.

<br>

---

<br>

## 4.3 로그

카프카의 토픽으로 들어오는 메시지는 세그먼트라는 파일에 저장된다.

정해진 형식에 맞춰 순차적으로 로그 세그먼트 파일에 저장되는데, 여기에는 메시지 내용, 메시지 key-value, 오프셋, 크기와 같은 정보가 함께 저장되고 브로커의 로컬 디스크에 보관된다.

로그 세그먼트의 최대 크기는 1GB로 설정되어 있고 만약 이보다 커지는 경우 새로운 세그먼트 파일을 생성한다.

<br>

### 4.3.1 로그 세그먼트 삭제

로그 세그먼트는 디스크에 저장되어 있기 때문에 디스크 공간을 효율적으로 사용하기 위해 삭제 정책이 필요하다.

kafka configs에서 `retention.ms`를 통해 로그 세그먼트의 유효기간을 설정할 수 있다.

만약, `retention.ms`가 7일로 설정되어 있다면 7일이 지난 로그 세그먼트는 삭제된다.(기본값은 7일)

<br>

### 4.3.2 로그 세그먼트 컴팩션

컴팩션은 로그 세그먼트의 관리 정책 중 하나로, 로그를 삭제하지 않고 컴팩션하고 보관한다.

카프카에서 로그 세그먼트를 컴팩션하면 메시지의 키 값을 기준으로 마지막 데이터만 보관하게 된다.

`__consumer_offsets` 토픽은 컴팩션을 통해 메시지의 키 값을 기준으로 마지막 데이터만 보관하고 있다.

로그 컴팩션은 메시지의 키 값을 기준으로 과거 정보는 중요하지 않고 가장 마지막 값이 필요한 경우에 사용한다.(ex: 배송 상태)

프로듀서가 메시지를 전송할 때 메시지의 value는 필수이지만 key는 필수가 아닌데, 만약 key가 없다면 컴팩션을 사용할 수 없으므로 로그 컴팩션 기능을 사용하고자 한다면 key를 반드시 포함하여 메시지를 보내야한다.

로그 컴팩션의 장점은 빠른 장애 복구이다.

전체 로그를 복구하는 것이 아니라 키를 기준으로 최신 상태만 복구하여 `downtime`을 줄일 수 있다.

또한, 로그 컴팩션 작업이 실행되는 동안 브로커의 과도한 입출력 부하가 발생할 수 있으므로 유의해야한다.(리소스 사용량 모니터링 필요)
























