# 6. 컨슈머의 내부 동작 원리와 구현

<br>

## 6.1 컨슈머 오프셋 관리

컨슈머는 메시지를 어디까지 가져왔는지를 표시하는 것이 매우 중요하다. 이를 위해 컨슈머는 오프셋을 관리한다.

컨슈머가 일시적으로 동작을 멈추고 재시작을 하거나 서버에 장애가 발생해 새로운 컨슈머가 기존 컨슈머의 역할을 대신하는 경우에 마지막 메시지 위치부터 메시지를 읽어야하므로 매우 중요하다.

컨슈머는 오프셋을 관리하기 위해 `__consumer_offsets` 토픽을 사용한다.

`__consumer_offsets`의 정보를 사용해 컨슈머 그룹은 자신의 그룹이 속한 컨슈머의 변경이 발생하는 경우(장애, 이탈) 해당 컨슈머의 마지막 위치를 추적한다.

<br>

## 6.2 그룹 코디네이터

컨슈머 그룹은 그룹 코디네이터를 통해 컨슈머 그룹의 상태를 관리한다.(새로운 컨슈머의 합류, 그룹에 속한 기존 컨슈머의 이탈)

이 경우 컨슈머 그룹은 각 컨슈머들의 변화를 감지하고 작업을 균등하게 분배해야한다.(리밸런싱)

그룹 코디네이터의 목적은 컨슈머 그룹이 구독한 토픽의 파티션들과 그룹의 멤버들을 트래킹하는 것이다.

그룹 코디네이터는 각 그룹별로 존재하며 카프카 클러스터 내의 브로커 중 하나에 위치한다.

컨슈머들의 변경을 감지하기 위해 그룹 코디네이터와 컨슈머는 하트비트를 주고받으며 이를 통해 컨슈머의 상태를 확인한다.

- heartbeat.interval.ms : 컨슈머가 살아있음을 확인하는 주기(session.timeout.ms보다 낮게 설정해야하며 1/3 수준이 적당)
- session.timeout.ms : 컨슈머가 살아있음을 확인하는 시간(해당 시간 내에 heartbeat를 받지 못하면 컨슈머는 죽은 것으로 간주)
- max.poll.interval.ms : 컨슈머가 poll을 호출하는 최대 시간(해당 시간 내에 poll을 호출하지 않으면 컨슈머는 죽은 것으로 간주)

컨슈머 리밸런싱 동작은 매우 높은 비용이 지출되므로 가급적 리밸런싱이 자주 발생하지 않도록 주의해야한다.

컨슈머의 다운을 빠르게 감지하도록 옵션을 조정한다면 일시적인 컨슈머의 타임아웃이나 tcp 패킷 손실로 인해 원치 않은 리밸런싱이 발생할 수 있으므로 주의해야한다.

반대로 컨슈머의 다운을 늦게 감지하도록 설정한다면 해당 시간만큼 파티션의 메시지를 읽지 못하는 현상이 발생할 수 있다.

<br>

## 6.3 스태틱 멤버십


컨슈머 그룹 내의 컨슈머를 순차적으로 재기동하고 싶은 경우가 있을 수 있는데, 일반적인 상황에서는 컨슈머가 재시작될 때마다 전체 컨슈머의 리밸런싱이 일어나고 이 작업동안 컨슈머들의 작업은 중지되므로 비효율적이다.

컨슈머 그룹 내의 각 컨슈머들은 고유한 엔티티 ID를 부여받게 되는데 재기동될때마다 새로운 엔티티 ID가 부여되므로 같은 컨슈머임에도 새로운 컨슈머로 인식하여 리밸런싱이 일어나게된다.

이러한 문제를 해결하기 위해 컨슈머 그룹 내의 컨슈머들이 고정된 멤버십을 가지도록 설정할 수 있다.

이를 통해 컨슈머가 재시작을 위해 그룹에서 이탈했다 다시 합류하더라도 리밸런싱이 일어나지 않게 한다.

스태틱 멤버십 기능이 적용된 컨슈머는 그룹에서 떠날 때 그룹 코디네이터에게 알리지 않으므로 불필요한 리밸런싱도 발생하지 않는다.

`group.instance.id` 옵션을 통해 컨슈머의 고유한 ID를 부여할 수 있다.

스태틱 멤버십 기능을 사용한다면 `session.timeout.ms`를 기본값보다 높게 설정해야한다. 재시작되는 중 그룹 코디네이터가 하트비트를 받지 못하여 불필요한 리밸런싱이 일어날 수도 있기 때문이다.

<br>

## 6.4 컨슈머 파티션 할당 전략

컨슈머 그룹의 리더 컨슈머가 정해진 파티션 할당 전략에 따라 각 컨슈머와 대상 토픽의 파티션을 매칭시킨다.

- Range 할당 전략
- Round-robin 할당 전략
- Sticky 할당 전략
- Cooperative 할당 전략

위 4가지의 파티션 할당 전략을 제공하고 있다.

<br>

### 6.4.1 Range 할당 전략

파티션 할당 전략 중 기본값으로 각 토픽별로 할당 전략을 사용한다.

구독하는 토픽에 대한 파티션을 순서대로 나열한 후 컨슈머를 순서대로 정렬한다.

전체 파티션 수를 컨슈머 수로 나누고 컨슈머에게 할당한다. 컨슈머의 수와 파티션의 수가 일치하면 균등하게 할당될 수 있지만 균등하지 않은 경우 앞쪽의 컨슈머들이 추가 파티션을 할당받는다.

불균형하게 할당될 수 있지만 동일한 레코드 키를 사용하고 하나의 컨슈머 그룹이 동일한 파티션 수를 가진 2개 이상의 토픽을 컨슘할때 유용하게 사용할 수 있다.

<br>

### 6.4.2 Round-robin 할당 전략

컨슘해야 하는 모든 파티션과 모든 컨슈머를 나열한 후 라운드 로빈으로 하나씩 파티션과 컨슈머를 할당하는 전략이다.

<br>

### 6.4.3 Sticky 할당 전략

컨슈머 그룹의 리밸런싱 동작으로 파티션이 재할당된다면 기존에 매핑된 파티션에 동일한 컨슈머가 재매핑되리라 보장할 수 없다.

Sticky는 컨슈머가 동일한 파티션을 계속해서 할당받아 처리할 수 있도록 하는 전략이다.

하지만 무조건 기존의 파티션과 컨슈머를 유지하지는 않는다. 균등한 분배가 최우선이므로 기존 매핑을 유지하지 못하게 될 수도 있다.

- 컨슈머들에게 할당된 파티션 수의 최대 차이는 1
- 기존에 존재하는 파티션 할당은 최대한 유지
- 리밸런싱시 유효하지 않은 모든 파티션 할당 제거
- 할당되지 않은 파티션들은 균형을 맞추며 컨슈머들에게 할당

<br>

### 6.4.4 Cooperative Sticky 할당 전략

결과적으로 본다면 스티키 전략과 동일한 방식이다. 리밸런싱이 일어나더라도 기존의 매핑은 유지하고 최소한의 파티션만 컨슈머와 매핑한다.

하지만 스티키 전략과 다르게 컨슈머가 할당받은 파티션을 직접 관리하며, 리밸런싱이 일어나더라도 할당받은 파티션을 유지한다.

EAGER 전력을 사용한 스티키 전략은 리밸런싱시 컨슈머에 할당된 모든 파티션을 취소하므로 한번의 리밸런싱 동작으로 모든 컨슈머와 파티션을 매핑할 수 있지만 리소스를 많이 사용하는 컨슈머 그룹에서 큰 문제가 된다.(다운타임)

즉, 모든 컨슈머와 모든 파티션의 연결이 해제된 다운타임동안 LAG는 급격하게 증가한다.

이는 대량의 메서지를 컨슘하는 경우에 매우 큰 부담이 될 수 있다.

협력적 스티키는 EAGER가 아닌 COOPERATIVE 프로토콜을 사용하여 리밸런싱이 동작하기 전의 컨슈머 상태를 유지한다.

이는 되도록 동작 중인 컨슈머들에게 영향을 주지 앟는 상태에서 몇 차례의 리밸런싱이 일어난다.

<br>
