# 10. 스키마 레지스트리

# 스키마 개념과 유용성

- 스키마
    - 정보를 구성하고 해석하는 것을 도와주는 프레임워크나 개념
    - ex. 데이터베이스의 구조를 정의, 표현방법이나 전반적인 명세/제약조건 기술
    - 카프카에서는 스키마 레지스트리라는 애플리케이션을 이용하여 스키마를 정의&활용
- 스키마를 정의하면 데이터 트러블슈팅 감소, 용이한 데이터 포맷 확인, 데이터스키마 관련 커뮤니케이션 감소등의 이점 존재

# 카프카와 스키마 레지스트리
<img width="781" alt="image" src="https://github.com/user-attachments/assets/9d0d8530-4074-4f1a-8b8b-76d40322a2b1">

- 스키마 레지스트리
    - 스키마를 등록하고 관리하는 애플리케이션 - 오픈소스 직렬화 시스템
    - 데이터 포맷으로는 Avro를 사용한다.
    - Avro 권장 이유
        - JSON과 매핑됨
        - 매우 간결한 데이터 포맷
        - JSON은 메시지마다 필드 네임들이 포함되어 전송되기 떄문에 효율이 떨어진다.
        - 바이너리 형태로 매우 빠르다.
- 스키마 레지스트리 사용하기
    - 카프카 서버에 레지스트리 설치 (일반적으로는 분리된 별도 서버에 하는 것을 추천)
        - 다운 받아 압축 해제 후 심볼릭 링크 설정
        - 브로커의 _schema 토픽
            
            → 스키마 레지스트리의 저장소로 활용
            → 스키마 관리 목적의 메시지들은 순서가 중요 하기 때문에 해당 토픽의 파티션 수는 항상 1
            
    - 스키마 레지스트리 설정
        - /user/local/confluent/etc/schema-registry/schema-registry.properties 파일 수정 - 포트, 토픽, 데이터 저장할 카프카 주소, 호환성 등
    - 잘 실행되는지 리스닝 포트 확인 or curl로 API 호출 확인

# 스키마 레지스트리 실습

- 프로듀서, 컨슈머 클라이언트가 스키마 레지스트리와 통신하는 방법
- 아래처럼 프로듀서, 클라이언트는 서로 지접 통신하진 않지만 스키마 레지스트리에 정보를 등록함으로서 컨슈머는 프로듀서가 정의한 스키마 정보를 알 수 있다.

<img width="815" alt="image" src="https://github.com/user-attachments/assets/37a2a005-69eb-4a7d-b532-729825a6a214">

- 책에 파이썬을 통한 실습 예제 참고

# 스키마 레지스트리 호환성

버젼별 스키마 관리

- 스키마가 진화에 따라 호환성 검사
- 테이터 포맷 변경에 따라 스키마 진화
- 진화에 따라 스키마 레지스트리 내에 버전별 스키마가 생성
- 호환성 레벨 : BACKWARD, FORWARD, FULL
    - BACKWARD 호환성
        - 진화된 스키마를 적용한 컨슈머가 진화 전의 스키마가 적용된 프로듀서가 보낸 메시지를 읽을 수 있게 허용 - 한 단계 아래 버전
        - 모든 하위 버전의 스키마 호환시 BACKWARD_TRANSITIVE
    - FORWARD 호환성
        - 진화된 스키마다 적용된 프로듀서가 보낸 메시지를 진화 전의 스키마가 적용된 컨슈머가 읽을 수 있게 허용 - 현재 단계 + 한 단계 위 버전까지
        - 모든 상위 버전의 스키마를 호환하고자 한다면 FORWARD_TRANSITIVE
    - FULL 호환성
        - BACKWARD, FORWARD 모두 지원
        - 자신과 동일한 버전 + 하나 위 or 아래 버전 지원
        - 모든 버전 스키마 버전 (상/하위) 을 호환하고자 한다면 FULL_TRANSITIVE
