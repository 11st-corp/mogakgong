# 파티셔너

카프카 클라이언트인 프로듀서의 기본 역할은 메시지들을 토픽으로 전송하는 것인데, 
이 메시지들은 프로듀서의 send() 메소드를 통해 시리얼라이저, 파티셔너를 거쳐 카프카로 전송된다.


---

## 5.1 파티셔너

카프카의 토픽은 성능 향상을 위한 병렬 처리가 가능하도록 하기 위해 파티션으로 나뉘고 하나 또는 둘 이상의 파티션으로 구성된다.
그리고 프로듀서가 카프카로 전송한 메시지는 토픽 내 각 파티션의 로그 세그먼트에 저장된다.

따라서 프로듀서가 메시지를 전송할 때 어떤 파티션에 메시지를 전송할지 결정하는 파티셔너가 필요하다.

기본적으로는 메시지(Record)의 키를 해시<sup>hash</sup>처리해 파티션을 구하는 알고리즘을 사용한다.
따라서 메시지의 키값이 동일하면 해당 메시지들은 모두 같은 파티션으로 전송된다.

또한 클라이언트의 처리량을 높이기 위해 토픽의 파티션을 늘릴 수 있는 기능이 제공되고 이 때 파티션 수가 변경됨가 동시에 메시지의 키와 매핑된 해시 테이블도 변경된다.
따라서 동일한 메시지의 키를 이용해 메시리를 전송하더라도 파티션의 수가 변경되면 다른 파티션으로 메시지가 전송될 수 있기 때문에 파티션 수를 변경하지 않는 것이 권장된다.

### 5.1.1 라운드 로빈 전략

메시지 중 레코드의 키값이 필숫값은 아닌데 이럴 경우 키값은 null이 되고 기본값인 라운드 로빈<sup>round-robin</sup> 알고리즘을 사용해 목적지 토픽의 파티션들로 랜덤 전송한다.
파티셔너를 거친 후의 레코드들은 배치 처리를 위해 프로듀서의 버퍼 메모리 영역에서 잠시 대기한 후 카프카로 전송되는데 이 과정에서 라운드 로빈 전략은 효율을 떨어뜨릴 수 있다.

배치 전송을 위한 최소 레코드 수가 N으로 설정되어 있다면 파티션별로 순차적으로 저장된 레코드의 수가 N을 충족하지 못하다면 전송되지 못한 채 프로듀서 내에서 대기하고 있게 된다.
따라서 라운드 로빈 전략은 효율적인 배치 전송을 위해 사용되지 않고 이를 보완하기 위해 Apache Kafka 2.4버전부터 스티키 파티셔닝<sup>sticky partitioning</sup>이라는 기능이 추가되었다.

### 5.1.2 스티키 파티셔닝 전략

라운드 로빈 전략에서 배치 전송을 위한 필요 레코드 수를 채우지 못해 배치전송을 하지 못했던 것과 달리,
스티키 파티셔닝이란 하나의 파티션에 레코드 수를 먼저 채워 카프카로 빠르게 배치 전송하는 전략이다.

이 전략은 기본 설정에 비해 약 30% 이상 지연시간이 감소하고 CPU 사용률도 줄어드는 효과가 있다고 한다. 만약 카프카로 전송하는 메시지의 순서가 중요하지 않다면 해당 전략을 적용하기를 권장한다.

## 5.2 프로듀서의 배치

카프카의 프로듀서는 메시지를 전송할 때 레코드 단위로 전송하는 것이 아니라 다량의 메시지를 묶어 배치 단위로 전송한다.

배치 전송을 위해 여러 옵션을 제공한다.
- buffer.memory: 프로듀서의 버퍼 메모리 크기를 설정한다. 기본값은 32MB이며 조정이 가능하다.
- batch.size: 프로듀서가 카프카로 전송하는 배치의 크기를 설정한다. 기본값은 16KB이며 조정이 가능하다.
- linger.ms: 프로듀서가 카프카로 전송하는 배치의 지연 시간을 설정한다. 기본값은 0이며 조정이 가능하다.

이러한 배치 전송은 불필요한 I/O를 줄일 수 있어 매우 효율적이며 카프카 요청 수를 줄여주는 효과도 있다.
1000개의 메시지를 카프카로 전송한다면 1000번의 요청과 응답이 발생하지만 프로듀서가 100개의 메시지를 배치로 처리한다면 카프카와 프로듀서에는 단 10번의 요청과 응답만 발생하기 때문이다.

하지만 장점이 많다고 해서 무조건 배치 처리를 해야하는 것은 아니며 사용 목적에 따라 처리량을 높일지, 지연 없는 전송을 해야할지 선택해야 한다.

처리량을 높이려면 *batch.size*와 *linger.ms*를 높이고, 지연 없는 전송을 원한다면 *batch.size*와 *linger.ms*를 낮추면 된다.

## 5.3 중복 없는 전송

일부 서비스는 메시지 중복을 허용하는 경우도 있지만 특정 서비스에서 메시지가 중복처리 된다면 치명적인 상황이 발생할 수 있다.
따라서 카프카에서는 중복 없는 전송(**멱등성 전송**)을 위한 옵션을 제공한다.

우선 메시지 시스템들의 메시지 전송 방식에는 
**'적어도 한번 전송', '최대 한 번 전송', '정확히 한 번 전송'** 세 가지 방식이 있다.

- 적어도 한번 전송
  - 여러 장애 상황에 따라 일부 메시지 중복이 발생할 수 있지만 최소한 하나의 메시지는 반드시 보장한다
  - 카프카는 기본적으로 이 방식을 사용한다.
- 최대 한번 전송
  - ACK 응답을 받지 못하더라도 메시지의 중복 가능성을 회피 하기 위해 재전송을 하지 않는다.
  - 일부 메시지 손실을 감안하더라도 중복 전송을 하지 않는 경우 사용한다.
  - 높은처리량을 필요로 하는 대량 로그 수집이나 IoT 같은 환경에서 사용된다.

카프카에서 사용되는 **중복없는 전송**을 알아보자.

카프카에서는 프로듀서가 전송한 메시지의 헤더에서 PID와 메시지번호(시퀀스번호)를 비교해서 브로커에 저장되어 있는지 확인하는 과정을 거친다.

이 방식을 적용한 후에 기존 대빛 최대 약 20% 정도 성능이 감소했다고 한다.
따라서 프로듀서 전송 성능에 민감하지 않은 상황에서 중복없는 메시지 전송이 필요하다면 해당 방식을 적용할 수 있다.

- `enable.idempotence`: 중복없는 전송을 위한 옵션으로 기본값은 false이다.
  - true로 설정 시 아래 옵션들도 반드시 변경해야 하고 그렇지 않으면 ConfigException이 발생한다.
- `max.in.flight.requests.per.connection`: 프로듀서가 카프카로 전송하는 최대 요청 수를 설정한다. 기본값은 5이며 조정이 가능하다.
- `acks`': 프로듀서가 카프카로 전송한 메시지에 대한 응답을 설정한다. 기본값은 1이며 all로 설정해야 한다.
- `retries`: 프로듀서가 카프카로 전송한 메시지에 대한 재전송 횟수를 설정한다. 0보다 큰 값으로 설정해야 하고 보통 5로 설정한다.

## 5.4 정확히 한번 전송

대부분 메시지 중복이나 손실이 발생하지 않기를 원하는데 가장 이상적으로 모든 메시지를 정확히 한번 처리해주길 원할 것이다.

위에서 본 중복 없는 전송이 정확히 한 번 전송한다는 의미는 아니다.

카프카에서 정확히 한 번 전송은 트랜잭션과 같은 전체적인 프로세스를 의미하며 중복 없는 전송은 정확히 한 번 전송의 일부 기능이라 할 수 있다.

### 5.4.1 디자인
이 방식으로 메시지를 전송할 때 프로듀서가 보내는 메시지들은 원자적으로<sup>atomic</sup> 처리되어 전송에 성공하거나 실패하게 된다.

이를 위해 서버 측에 트랜잭션 코디네이터<sup>Transaction Coordinator</sup>가 존재한ㄷ.ㅏ

이 역할은 프로듀서에 의해 전송된 메시지를 관리하며, 커밋 또는 중단 등을 표시한다.

카프카에서는 consumer offset 관리를 위해 offset정보를 카프카 내부 토픽에 저장하는데, 트랜잭션도 동일하게 트랜잭션 로그를 카프카 내부 토픽인 `_transaction_state`에 저장한다.
프로듀서가 트랜잭션 관련 정보를 코디네이터에게 알리면 코디네이터는 해당 정보를 트랜잭션 로그에 저장한다.

정확히 한 번 전송을 위해 프로듀서에 필수로 설정해야 하는 옵션들이 있다.