# 프로듀서의 내부 동작 원리와 구현

<br>

## 5.1 파티셔너

카프카 토픽은 병렬 처리를 위해 최소 하나 이상의 파티션으로 구성된다.

프로듀서는 메시지를 특정 파티션에 전송하기 위해 파티셔너를 사용한다. 기본적으로 메시지의 키를 해싱하여 전송할 파티션을 구하는 방식을 사용한다.

이 방식은 메시지의 키가 동일한 경우 동일한 파티션으로 메서지를 전송하게된다.

급격한 메시지 증가로 인해 트래픽이 늘어날 경우를 위해 카프카는 처리량을 높이기 위해 토픽의 파티션을 늘릴 수 있는 기능을 제공한다.

파티션 수가 변경되면 메시지의 키와 매핑된 파티션도 변경되므로, 파티션 수를 변경할 때는 주의해야한다.

<br>

### 5.1.1 라운드 로빈 전략

만약 메시지의 키가 없다면 라운드 로빈 전략을 사용한다.

배치 전송을 위해 프로듀서의 버퍼 메모리 영역에 메세지를 특정 수만큼 모아두었다가 한번에 전송하는데, 라운드 로빈 전략에서는 메시지를 순차적으로 전송하기 때문에 효율이 떨어질 수 있다.

<br>

### 5.1.2 스티키 파티셔닝 전략

스티키 파티셔닝은 하나의 파티션에 레코드 수를 먼저 채워 카프카로 빠르게 배치 전송하는 전략이다.

스티키 전략을 통해 약 30%이상의 지연시간 감소와 CPU 사용률 감소의 효과를 얻을 수 있다.

메서지의 순서가 중요하지 않은 경우에 사용하는 것이 좋다.

<br>

## 5.2 프로듀서의 배치 

배치 전송을 위한 옵션
- `buffer.memory` : 프로듀서의 버퍼 메모리 크기
- `batch.size` : 배치 전송을 위한 메시지 크기
- `linger.ms` : 배치 전송을 위한 대기 시간
  - 0으로 설정하면 대기하지 않고 즉시 전송

배치 전송을 통해 처리량과 성능을 높일지, 지연시간을 줄일지 선택할 수 있다.

만약, 지연 없는 즉시 전송이 목적이라면 배치 전송을 사용하지 않는 것이 좋다.

처리량을 높이기 위해서는 `batch.size`와 `linger.ms`를 적절히 조절해야한다.

`buffer.memory`의 크기는 반드시 `batch-size`의 크기보다 커야한다.

배치 전송과 압축 기능을 함께 사용하면 더욱 더 성능을 높일 수 있다.

<br>

## 5.3 중복 없는 전송

### 적어도 한번

![01.png](resource%2F01.png)

ACK를 주고받는 과정을 통해 중복 전송이 발생할 수는 있지만 적어도 한번은 메세지 전송이 보장되는 방식이다.(기본 방식)

<br>

### 최대 한번

![02.png](resource%2F02.png)

ACK에 상관없이 한 번씩 전송하기 때문에 중복 전송은 발생하지 않지만 메시지 유실이 발생할 수는 있다.

즉, 메시지의 손실을 감안하더라도 중복 전송을 하지 않는다.

일부 메시지가 손상되더라도 높은 처리량을 목표로하는 곳(대량 로그수집, IoT)에서 주로 사용된다.

<br>

### 중복 없는 전송

![03.png](resource%2F03.png)

ACK를 주고받으며 메시지를 재전송한다는 점은 적어도 한번과 동일하지만 메시지의 헤더에 PID와 메시지 시퀀스 번호를 포함해서 메시지를 전송하기 때문에 중복 전송을 하긴하지만 브로커는 헤더값을 통해 중복 메시지를 저장하지 않고 ACK만 프로듀서에게 보낸다.

PID와 메시지의 시퀀스 번호는 브로커의 메모리와 리플리케이션 로그에 저장되기 때문에 브로커 장애로 인해 리더가 변경되더라도 새로운 리더가 PID와 시퀀스 번호를 알 수 있다.

중복을 피하기 위한 비교 과정에서 오버헤드가 존재할 수 밖에 없지만 해당 부분을 최소화하였고 전송 성능에 민감하지 않는 시스템에서 중복없는 전송이 필요하다면 이 방식을 고려해볼 수 있다.

<br>

## 5.4 정확히 한 번 전송

카프카에서는 정확히 한 번 처리를 담당하는 트랜잭션 API를 제공한다.

<br>

### 5.4.1 디자인

프로듀서가 카프카로 정확히 한 번 방식을 사용해 메서지를 전송하면 프로듀서의 메시지는 원자적으로 처리된다.(전체 성공 or 전체 실패)

트랜잭션 코디네이터라는 것이 서버에 존재하는데, 이는 프로듀서에 의해 전송된 메시지를 고나리하며 커밋, 중단등을 표시한다.

트랜잭션 로그는 카프카의 내부 토픽(__transaction_state)에 저장되고, 파티션 수와 리플리케이션 팩터 수를 지정할 수 있다.

정확히 한번 전송을 통해 전송된 메시지들이 카프카에 저장되면 클라이언트들은 메시지의 커밋, 중단 상태를 식별할 수 있어야하는데 이를 위해 컨트롤 메시지라는 특별한 타입의 메시지가 사용된다.

이는 페이로드에 메시지의 값을 포함하지 않으며 애플리케이션들에게 노출되지 않고 오로지 브로커와 클라이언트 통신에서만 사용된다.

